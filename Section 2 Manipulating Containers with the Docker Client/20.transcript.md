This section demonstrates a **key concept in container isolation** — that processes inside a Docker container are self-contained and **not visible or directly accessible from the host OS** unless you explicitly connect or execute commands inside that container.

Here’s the breakdown:

---

### **1. Normal Redis Behavior (Without Docker)**

When Redis is installed **natively** on your local machine:

```bash
redis-server
```

* Starts the **Redis server** process on your host.
* Listens on TCP port `6379` by default.

Then in a second terminal:

```bash
redis-cli
```

* Connects to the Redis server running locally on `localhost:6379`.
* You can issue commands:

  ```bash
  set mynumber 5
  get mynumber
  ```

  → Outputs `5`

So in this traditional setup:

* **Redis server and Redis CLI share the same OS environment.**
* Both processes can see and communicate over the local loopback (`127.0.0.1`).

---

### **2. Redis with Docker**

Now you start Redis inside a container:

```bash
docker run redis
```

What this does:

* Pulls the `redis` image (if not already present).
* Starts a **new container**.
* The `redis-server` process runs *inside that isolated container*.
* Docker gives it a virtual network interface that’s separate from your host.

You’ll see output like:

```
* Ready to accept connections
```

At this point:

* Redis is running **inside** the container.
* The host system (your computer) **can’t see or talk to it directly** unless you’ve exposed ports.

---

### **3. The Problem**

When you try this from the host:

```bash
redis-cli
```

You’ll likely get:

```
Command 'redis-cli' not found
```

or

```
Could not connect to Redis at 127.0.0.1:6379: Connection refused
```

Why?

* The `redis-cli` command is **not installed on your host** (it exists only in the container).
* The Redis server is **not listening on your host network**, only inside the container’s private network namespace.

---

### **4. The Container Isolation Diagram**

```
+------------------------------+
|       Docker Container       |
|------------------------------|
| redis-server (running)       |
|                              |
| <-- isolated filesystem -->  |
| <-- isolated network -->     |
+------------------------------+

+------------------------------+
|          Host System         |
|------------------------------|
| redis-cli  ❌  not installed  |
| no access to container's net |
+------------------------------+
```

So your host’s CLI can’t talk to the Redis instance running in Docker by default.

---

### **5. The Correct Way to Access Redis Inside Docker**

There are **two approaches** to interact with the running container’s Redis process:

#### **Option 1: Execute Redis CLI inside the container**

Use:

```bash
docker exec -it <container_id> redis-cli
```

* `exec` = run a new command in an existing container.
* `-it` = interactive + terminal.
* `redis-cli` = command to execute inside.

Now you’ll get a Redis prompt:

```
127.0.0.1:6379>
```

And you can do:

```bash
set mynumber 5
get mynumber
```

→ Returns `5`

You’re now **running the CLI inside the same container** where the server is running, sharing its network space.

---

#### **Option 2: Expose Redis Port to the Host**

You could start Redis with port mapping:

```bash
docker run -d -p 6379:6379 redis
```

This tells Docker:

* Forward traffic from **host port 6379** → **container port 6379**.

Now you can install and run Redis CLI **on your host**:

```bash
sudo apt install redis-tools  # Debian/Ubuntu
redis-cli -h 127.0.0.1
```

And you’ll be connected to the Redis container running on the mapped port.

---

### **6. Key Takeaways**

| Concept                 | Without Docker                       | With Docker                            |
| ----------------------- | ------------------------------------ | -------------------------------------- |
| **Redis server**        | Runs on host OS                      | Runs inside container                  |
| **CLI access**          | Direct via `redis-cli`               | Must use `docker exec` or port mapping |
| **Network visibility**  | Host and server share same localhost | Container isolated on Docker network   |
| **Command to interact** | `redis-cli`                          | `docker exec -it <id> redis-cli`       |

---

### **7. Why This Matters**

This is your first practical example of **process and network isolation in containers**:

* Each container acts like a small, self-contained machine.
* You can run multiple Redis instances — each in separate containers — without conflict.
* But you must **explicitly expose** or **enter** containers to interact with their processes.

---

In the next step (as your course will show), you’ll learn **how to execute additional commands inside a running container** using `docker exec`.
That’s exactly how you’ll open a Redis CLI session inside the container you just started.
