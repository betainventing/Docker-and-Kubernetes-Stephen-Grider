Here’s the summary and clarification of this section:

---

### **1. Alternate Way to Get a Shell**

Instead of using `docker exec` on an **already running container**, you can start a **new container with a shell** immediately by using:

```bash
docker run -it <image> sh
```

* `-it` → attach to stdin and allocate a pseudo-terminal.
* `<image>` → the container image you want to run (e.g., `busybox`).
* `sh` → starts a shell inside the new container.

This gives you an **interactive shell in a fresh container** right from the start.

---

### **2. How It Differs from `docker exec`**

* `docker exec` → used to attach to a **running container** and start a new process (like a shell) inside it.
* `docker run -it sh` → creates a **brand new container** and immediately runs a shell instead of any default process.

---

### **3. Practical Notes**

* Using `docker run -it <image> sh` is useful for **exploration or debugging**, because you start with a minimal container environment.
* Downside: **no other default process** runs in this container unless you explicitly start it.
* Common practice: start your container normally with its primary service, then attach a shell later with `docker exec -it <container_id> sh`.

---

### **4. Example Commands Inside the Shell**

Once inside:

```bash
ls
ping google.com
echo "hello from container"
```

Exit the shell:

* `Ctrl+C` or `Ctrl+D`.

---

**Key Takeaway:**

> `docker run -it <image> sh` gives you a brand-new container with an interactive shell, while `docker exec -it <container_id> sh` gives you a shell in an **existing running container**. Most production debugging uses `exec`, but `run` is great for exploratory testing.
