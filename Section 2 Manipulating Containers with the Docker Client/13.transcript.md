This section explains how to **override the default startup command** in a Docker image when running a container. It’s an essential concept for understanding how containers behave and how to control what runs inside them.

Let’s break it down technically:

---

### **1. Recap of `docker run` Behavior**

When you run:

```bash
docker run <image_name>
```

Docker does **two main things:**

1. Creates a new container from the image.
2. Executes the **default command** defined in that image (via `CMD` or `ENTRYPOINT` in the Dockerfile).

---

### **2. Overriding the Default Command**

You can override that default command by adding your own at the end of the `docker run` command:

```bash
docker run <image_name> <alternate_command>
```

Example:

```bash
docker run busybox echo hi there
```

This tells Docker:

> “Create a container from the `busybox` image and instead of running its default command, execute `echo hi there`.”

Output:

```
hi there
```

That’s because the `echo` command exists **inside the BusyBox image’s filesystem**.

---

### **3. Another Example**

```bash
docker run busybox ls
```

Output:

```
bin
dev
etc
home
proc
root
sys
usr
var
```

This shows the directory structure **inside the BusyBox container**, not your host machine.
These directories come from the **filesystem snapshot** baked into the image.

---

### **4. Why `hello-world` Fails with Overrides**

When you run:

```bash
docker run hello-world ls
```

or

```bash
docker run hello-world echo hi there
```

You get an error like:

```
exec: "ls": executable file not found in $PATH
```

Reason:

* The `hello-world` image contains only **one binary file** (the one that prints the welcome message).
* It does **not include utilities** like `ls` or `echo`.
* So, when you override the default command with something not present in the image’s filesystem, the container fails.

---

### **5. Why Use BusyBox**

BusyBox is a **lightweight Linux image** that includes many common Unix utilities (`ls`, `echo`, `cat`, `sh`, etc.) in a single binary.
That makes it perfect for demonstrations, testing, and debugging because you can execute most shell commands inside it.

---

### **6. Summary**

| Command                            | Description                           | Result            |
| ---------------------------------- | ------------------------------------- | ----------------- |
| `docker run hello-world`           | Runs default command (prints message) | Works             |
| `docker run hello-world ls`        | Tries to run `ls` (not in image)      | Error             |
| `docker run busybox ls`            | Runs `ls` inside BusyBox filesystem   | Lists directories |
| `docker run busybox echo hi there` | Runs `echo` inside container          | Prints “hi there” |

---

If you want, I can show you **how to inspect an image’s default command** (`CMD` and `ENTRYPOINT`) using `docker inspect` — this helps explain why some images behave differently when you override their commands. Would you like that next?
